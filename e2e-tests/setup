#!/bin/bash

set -e -u

warn() {
    echo "$1"
    exit 1
}

# A comment... but the comment ends up in the script output.
X##() {
    PURPLE='\033[0;36m'
    NC='\033[0m' # No Color
    echo -e "$PURPLE$1$NC"
}

# Normally we use this to verify we are getting an exit code of 1
# This protects us from hiding problems like a panic (exit 2).
run_and_verify() {
    expected=$1
    exit_code=0
    shift
    GOCOVERDIR=$PWD/gocov-datafiles \
        $TB --update-is-error "$@" || exit_code=$?

    if [ $exit_code -ne $expected ]; then
        RED='\033[0;31m'
        NC='\033[0m' # No Color
        echo -e "${RED}Test failed with error code: $exit_code, expected $expected.$NC"
        exit 1
    fi

    # Uncomment this if you want to walk through each test output.
    # read z
}

validate() {
	rm -fr x/files-validate
	mkdir x/files-validate
	run_and_verify 0 restore --file-path=$PWD/x/files-validate $CFG
	diff -r x/files x/files-validate
}

TB=./toobig

rm -fr x
mkdir x
mkdir x/{files,files2,blobs,blobs2,refs,refs2,dup}

CFG="x/update.cfg"
cat <<EOF >$CFG
{
"file-path": "files",
"ref-path": "refs",
"blob-path": "blobs",
"dup-path": "dup"
}
EOF
